let mQInit0 = lift @i.
  let qinitStep = lift @j. \(qs,u) :: (List[_<j] Qubit, ()). let q = apply(QInit0, u) in qs:q
  in fold(qinitStep, [], MakeUnitList @ i)
in

-- the function that applies the hadamard gate to a list of qubits
let mHadamard = lift @i . \x :: List[_<i] Qubit .
  let hadamardStep = lift @j . \(qs,q) :: (List[_<j] Qubit, Qubit).
    let q = apply(Hadamard,q) in
    qs:q
  in fold(hadamardStep, [], x)
in

-- the function that applies the X gate to a list of qubits
let mX = lift @i . \x :: List[_<i] Qubit .
  let xStep = lift @j . \(qs,q) :: (List[_<j] Qubit, Qubit).
    let q = apply(PauliX,q) in
    qs:q
  in fold(xStep, [], x)
in

-- the function that applies a measurement to a list of qubits
let makeNMeasure = lift @i . \x :: List[_<i] Qubit .
  let measureStep = lift @j . \(qs,q) :: (List[_<j] Bit, Qubit).
    let q = force meas q in
    qs:q
  in fold(measureStep, [], x)
in

-- the diffusion operator
let diffusion = lift @i. \reg:: List[_<i+1] Qubit.
  let reg = (force mHadamard @ i+1) reg in
  let reg = (force mX @ i+1) reg in
  let (xs:x) = reg in
  let (xs,x) = (force mcZ @ i) xs x in
  let reg = xs:x in
  let reg = (force mX @ i+1) reg in
  (force mHadamard @ i+1) reg
in

-- Performs a single grover iteration on a i-qubit input, using a j-wide oracle
let groverIteration = lift @i. @j.
  \oracle :: Circ[j](List[_<i+1] Qubit, List[_<i+1] Qubit). \reg :: List[_<i+1] Qubit.
    let reg = apply(oracle, reg) in
    (force diffusion @ i) reg
in

-- Runs Grover's algorithm on an oracle of input size i and width at most j
--Note that j in Circ[j] is HO and therefore should be adjusted depending on the resource for tighter bounds
let grover = lift @i. @j. \oracle :: Circ[j](List[_<i+1] Qubit, List[_<i+1] Qubit).
  let inputs = force mQInit0 @ i+1 in
  let prepared = (force mHadamard @ i+1) inputs in
  let iteration = lift @k. \(qs, _) :: (List[_<i+1] Qubit, ()) . (((force groverIteration) @ i) @ j) oracle qs in
  let out = fold(iteration, prepared, range @ 3) in
  -- 3 is a placeholder, should be floor(pi/4 * sqrt(2^(i+1))), but our arithmetic is not yet this rich
  (force makeNMeasure @ i+1) out
in 

-- The oracle f : {0,1}^4 -> {0,1} such that f(x) = 1 iff x = 1111
let oracleOne = box $ lift \reg :: List[_<4] Qubit.
  -- Initialize an ancilla for kickback
  let ancilla = force qinit1 () in
  let ancilla = force hadamard ancilla in
  -- Ancilla is flipped iff input is 1111
  let (reg, ancilla) = (force mcnot @ 4) reg ancilla in
  -- Uncompute and discard ancilla
  let ancilla = force hadamard ancilla in
  let _ = force qdiscard ancilla in
  -- Return the input
  reg
in

-- Run Grover on oracleOne
(force grover @ 3 @ 5) oracleOne