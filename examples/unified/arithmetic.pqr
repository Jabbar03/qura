{-
  Basic quantum arithmetic operations.
  from Vlatko Vedral, Adriano Barenco and Artur Ekert. Quantum Networks for Elementary Arithmetic Operations. Physical Review A, 54(2):147-153, 1996.
  This implementation of quantum arithmetic is by no means state-of-the-art, but it employs ancillary qubits
  to perform the operations, so its analysis is interesting.
-}

--- list functions ---

-- reverses a list of i qubits
let rev = lift @i.\list::List[i] (Qubit,Qubit).
  let revStep = lift @j.\(qs, q)::(List[j] (Qubit,Qubit), (Qubit,Qubit)). q:qs
  in fold(revStep, [], list)
in

let pair = lift @i . \a::List[i+1] Qubit.\b::List[i+1] Qubit.
  let pairStep = ((lift @j. \(reslist, sndlist, elem) :: (List[j] (Qubit,Qubit), List[i-j+1] Qubit, Qubit) .
    let head:tail = sndlist in ((elem, head) : reslist, tail))
    :: !(j ->[0, 0] (((List[j] (Qubit, Qubit), List[((i - j) + 1)] Qubit), Qubit) -o[(((j * 2) + ((i - j) + 1)) + 1), 0] (List[(j + 1)] (Qubit, Qubit), List[(((i - j) + 1) - 1)] Qubit)))) in
  let (reslist,_) = fold(pairStep, ([], b), a)
  in ((force rev) @i) reslist
in

let interleave = lift @i . \a :: List[i] (Qubit,Qubit). 
  let interleaveStep = lift @j . \(reslist, elem) :: (List[j] ((Qubit,Qubit),Qubit), (Qubit,Qubit)).
    let c = apply(QInit0,()) in (elem,c):reslist
  in fold(interleaveStep, [], ((force rev) @i) a)
in 

--- short-hands ---

let not = lift \a :: Qubit. apply(PauliX, a) in
let cnot = lift \a :: Qubit.\b :: Qubit. apply(CNot, (a,b)) in
let toffoli = lift \a :: Qubit.\b :: Qubit.\c :: Qubit. apply(Toffoli, (a,b,c)) in


--- Circuits ---

-- CARRY (Fig. 3.i)
let carry = lift \(c, a, b, cnext) :: (Qubit, Qubit, Qubit, Qubit).
  let (a, b, cnext) = (force toffoli) a b cnext in
  let (a,b) = (force cnot) a b in
  let (c, b, cnext) = (force toffoli) c b cnext in
  (c, a, b, cnext)
in

-- SUM (Fig. 3.ii)
let sum = lift \(c, a, b) :: (Qubit, Qubit, Qubit).
  let (a,b) = (force cnot) a b in
  let (c, b) = (force cnot) c b in
  (c, a, b)
in

-- ADDER
-- (Fig. 2, first half)
let adderFirstPhase = lift @i . \(a,b)::(List[i] Qubit, List[i] Qubit) .
  let ab = ((force pair) @i) a b in --even positions are a, odd positions are b
  let abc = ((force interleave) @i) ab in --every first position is a, every second is b, every third is c
  let initialAcc = apply(QInit0,()) in
  let step = lift @j . \(acc, elem) :: ((List[j] (Qubit,Qubit,Qubit),Qubit), (Qubit,Qubit,Qubit)) .
    let (a,b,cnext) = elem in
    let (reslist, c) = acc in
    let (c, a, b, cnext) = (force carry) (c, a, b, cnext) in
    ((c, a, b) : reslist, cnext) in
  let (reslist,clast) = fold(step, ([], initialAcc), abc) in
  let _ = apply(QDiscard,clast) in
  reslist -- note that the output triples are reversed
in
--adderFirstPhase :: !(i ->[0,0] (List[i] Qubit, List[i] Qubit) -o[3*i+1,0] List[i] (Qubit, Qubit, Qubit))

let adderSecondPhase = lift @i . \(cfirst, abc) :: (Qubit,List[i] (Qubit,Qubit,Qubit)).
  --subcircuit used in the second phase: carry followed by sum, carry discarded:
  let csum = box[(Qubit,Qubit,Qubit,Qubit)] lift \(c,a,b,cnext) :: (Qubit,Qubit,Qubit,Qubit). 
      let (c,a,b,cnext) = (force carry) (c,a,b,cnext) in
      let (c,a,b) = (force sum) (c,a,b) in
      let _ = apply(QDiscard,cnext) in
      (c,a,b) in
  --step function:
  let step = lift @j. \(acc,elem) :: ((Qubit, (List[j] (Qubit,Qubit))),(Qubit,Qubit,Qubit)).
    let (c,a,b) = elem in
    let (cnext, reslist) = acc in
    let (c,a,b) = apply(csum, (c,a,b,cnext)) in
    (c, (a,b):reslist)
  in fold(step, (cfirst,[]), abc)
in

adderSecondPhase

-- --whole adder circuit:
-- let adder = lift @i . \(a,b) :: (List[i] Qubit, List[i] Qubit) .
--   let intermediate = ((force adderFirstPhase) @i) (a,b) in
--   let (lastblock, rest) = (Head @(i-1)) intermediate in
--   let (c,a,b) = lastblock in
--   let (a,b) = (force cnot) a b in
--   let (c,a,b) = (force sum) (c,a,b) in
--   let final = ((force adderSecondPhase) @i) (c, rest) in
--   (force rev) @i ((a,b) : ((force rev) @(i-1)) final) --rearrange blocks so they are in order
-- in

-- adder