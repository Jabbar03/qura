let qrev = lift @n. \qs :: List[i<n] Qubit.
  let revStep = lift @i.\(qs, q) :: (List[k<i] Qubit, Qubit).
    qs:q
  in
  fold(revStep, [], qs)
in

-- rotationStep @n @m ((trg, ctrls), ctrl) applies a controlled rotation gate to trg with control ctrl. Then ctrl is added to the list of previous controls ctrls.
-- the magnitude of the rotation depends on m (the iteration of the qft) and k (the qubit serving as control)
let rotationStep = @m. lift @k.\((ctrls, trg), ctrl) :: ((List[j<k] Qubit, Qubit), Qubit).
    let rotation = force cR @ (m+1-k) in 
    let (ctrl, trg) = rotation ctrl trg in
    (ctrls:ctrl, trg)
in

-- qft @n reg applies the quantum fourier transform to a list of n qubits
let qft = @n.\reg :: List[j<n] Qubit.
  -- qftStep @m (ctrls, trg) applies the m-th iteration of the qft algorithm to the target qubit trg
  -- which consists of m rotations with target the m-th qubit and control each of the qubits preceding it
  -- followed by a hadamard gate on the target
  let qftStep = lift @m.\(ctrls, trg) :: (List[j<m] Qubit, Qubit).
      let revctrls = (force qrev @m) ctrls in
      let (ctrls, trg) = fold(rotationStep @m, ([], trg), revctrls) in
      let trg = force hadamard trg in
      ctrls:trg
  in
  fold(qftStep, [], reg)
in

qft