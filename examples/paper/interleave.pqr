-- At each step, take one qubit from the list, init a new qubit and cons both to the accumulator
let interleaveStep = ((lift \arg :: (List[2*i] Qubit, Qubit) .
  let (acc, elem) = arg in
  let new = apply(QInit,()) in
  new:elem:acc) :: !((List[2*i] Qubit, Qubit) ->[2*(i+1),0] List[2*(i+1)] Qubit))
in

-- interleave qs produces a new list of qubits in which a fresh qubit is added after each qubit in qs
let interleave = fold[i] interleaveStep [] in
interleave

-- Expected type: "List[k] Qubit ->[2 * k,0] List[(2 * k)] Qubit" or equivalent

-- Note that for all k:
-- max[i < k] 2*(i + 1) + k - (i + 1) =
-- max[i < k] (i + 1) + k =
-- k + k =
-- 2*k