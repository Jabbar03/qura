-- At each step, take one qubit from the list, init a new qubit and cons both to the accumulator
let interleaveStep = lift @i . ((\arg :: (List[2*i] Qubit, Qubit) .
  let (acc, elem) = arg in
  let new = apply(QInit0,()) in
  new:elem:acc)
  :: (List[2*i] Qubit, Qubit) -o[2*(i+1),0] List[2*(i+1)] Qubit)
in

let interleave = @j. \x :: List[j] Qubit . fold(interleaveStep, [], x)
in interleave @3 [apply(QInit0,()), apply(QInit0,()), apply(QInit0,())]
